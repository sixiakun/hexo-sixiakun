---
title: vue3.0迭代计划（译文）
---
译自：[Plans for the Next Iteration of Vue.js](https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf)，翻译一遍，好像比起看一遍要记忆更深一点。

上周在vue.js伦敦，我简要介绍了vue下一个主要版本即将发布的内容。这篇文章提供了对该计划的深入概述。

## 为什么会发布一个major版本？

vue 2.0在两年前发布（时间过得真快！）。在这段时间里，vue的核心部分已经进行了5个次要版本的兼容。
我们推迟了很多能改进vue的想法，因为他们有可能带来不兼容的改变。与此同时，js生态系统和语言本身也在快速发展。有很多强大的工具可用来增强我们的工作流程，js的很多新特性也可以为vue想要解决的问题提供一些更简单，更有效率，更完善的解决办法。更令人兴奋的是，es2015的支持成为了几乎所有主流浏览器的基准。Vue 3.0旨在利用这些新的语言特性，使Vue核心更小，更快，更强大。

Vue 3.0目前处于原型设计阶段，我们已经实现了一个接近功能奇偶校验的运行时2.x​​。**下面列出的许多项目已经实施或确认可行。尚未实施或仍处于勘探阶段的标记为*。**

# 详细内容

## 高级api修改

> 概要：除render函数API和作用域插槽语法之外的所有内容都将保持不变，或者可以通过兼容性构建使其兼容2.x

这是一个新的major，会有一些突破性的变化。但是，我们很重视向后兼容性，因此我们希望尽快开始传达这些更改。
以下是当前计划的公共API更改：

* template语法将保持99％相同。在作用域槽语法中可能会有一些小的调整，除此之外我们没有计划为模板更改任何其他内容
* 3.0将原生支持基于类的组件，旨在提供在原生ES2015中使用的API，无需任何转换或stage-x功能。大多数当前选项在基于类的API中具有合理的映射。Stage-x功能（如类字段和装饰器）仍可以选择性地用于增强创作体验。此外，API在设计时考虑了TypeScript类型推断。3.x代码库本身将使用TypeScript编写，并提供改进的TypeScript支持。（也就是说，在应用程序中使用TypeScript仍然是完全可选的。）
* 通过在内部将对象转换为相应的类，仍将支持2.x基于对象的组件格式。
* Mixins仍将受到支持。*
* 为避免插件安装时全局变更Vue运行时，顶级API可能会有较大的改动。插件将应用并作用于组件树。这样可以更轻松地测试依赖于特定插件的组件，还可以使用不同的插件在同一页面上安装多个Vue应用程序，但使用相同的Vue运行时。*
* 功能组件可以通过普通函数编写 - 但是，现在需要通过辅助函数显式创建异步组件。
* 将获得最多更改的部分是render函数中使用的Virtual DOM格式。我们目前正在收集主要库作者的反馈意见，当我们对这些变化更有信心时将分享更多细节。但只要您不严重依赖应用程序中的手写（非JSX）渲染功能，升级应该是一个相当简单的过程。

## 源码架构

> 概要：更好的解耦内部模块，TypeScript和更容易贡献的代码库

我们正在从头开始重新编写3.0，以实现更清晰，更易维护的架构，特别是尝试使其更容易做出贡献。我们将一些内部功能分解为单独的包，以便隔离复杂性。例如，观察者模块将成为自己的包，具有自己的公共API和测试。请注意，这不会影响框架级API - 您不必手动导入多个包以使用Vue。相反，最终的Vue包使用这些内部包进行组装。

代码库现在用TypeScript编写。虽然这可能使得TypeScript的熟练程度成为为新代码库做出贡献的先决条件，但我们相信类型信息和IDE支持实际上将使新贡献者更容易做出有意义的贡献。

将观察者和调度程序分离到单独的包中还允许我们轻松地尝试这些部分的替代实现。例如，我们可以使用相同的API实现IE11兼容的观察器实现，或者利用requestIdleCallback在长时间更新期间向浏览器提供的替代调度。*

![图找不到了](/img/20190505-01.png)

## 观察机制

> 概要：更完整，精确，高效和可调试的反应性跟踪和用于创建可观察的API。

3.0将附带基于proxy的观察器实现，该实现提供具有完整语言覆盖的反应性跟踪。
这消除了基于Object.defineProperty的Vue 2当前实现的许多限制：

* 对象新属性的添加/删除
* 数组基于索引或length的改动
* 对Map, Set, WeakMap 和 WeakSet的支持

新observer还具有以下特性：

* 用于创建可观察对象的公开API。这为中小规模场景提供了轻量级，简单的跨组件状态管理解决方案。
* 默认懒惰观察。在2.x中，任何被动数据，无论其大小，都会在启动时被观察到。如果您的数据集很大，这可能会导致应用启动时出现明显的开销。在3.x中，只需要观察用于渲染应用程序初始可见内容的数据，更不用说观察本身也要快得多。
* 更精确的变动通知。例如：在2.x中，使用Vue.set添加新属性将导致依赖于对象的任何观察者重新评估。在3.x中，只会通知依赖于该特定属性的观察者。
* 不可变的observables：我们可以创建一个值的“不可变”版本，即使在嵌套属性上也可以防止突变，除非系统在内部暂时解锁它。这种机制可用于冻结传递的道具或Vuex状态树以外的突变。
* 更好的调试功能：我们可以精确地跟踪使用新的renderTracked和renderTriggered挂钩跟踪或触发组件重新渲染的时间和原因：

![图找不到了](/img/20190505-02.png)

## 其他运行时改进

> 概要：更小，更快， tree-shakable的功能，fragments和portals，自定义renderer API。

* 更小：新的代码库从一开始就设计为易于使用tree-shaking。现在，按需和树可动态导入内置组件（&lt;transition&gt;，&lt;keep-alive&gt;）和指令运行时助手（v-model）等功能。*新运行时的常规大小为<10kb gzip*。此外，tree-shaking还允许我们在未来提供更多内置功能，而不会对不使用它们的用户造成负载惩罚。
* 更快：在初步基准测试中，我们看到全面的性能提升高达100％，包括原始Virtual DOM安装和修补（我们从[Inferno](https://infernojs.org/)学到了很多技巧，最快的Virtual DOM实现），组件实例初始化和数据观察。3.0在您应用程序启动时，花费在js上的时间减少了一半。
* Fragments和Portals：尽管尺寸变小了，但3.0内置支持Fragments（返回多个根节点的组件）和Portals（在DOM的另一部分中呈现子树，而不是在组件内部）
* 改进的插槽机制：所有编译器生成的插槽现在都是函数，并在子组件的渲染调用期间调用。这确保了插槽中的依赖关系被收集为子组件而不是父组件的依赖关系。
这意味着：1。当插槽内容发生变化时，只有子组件重新渲染;2.当父组件重新渲染时，如果其插槽内容没有改变，则子组件不必。此更改在组件树级别提供更精确的更改检测，因此更少的无用重新渲染！
* 自定义RendererAPI：用于创建自定义渲染器的API将可用，不再需要fork Vue代码库来自定义修改来。这将使像Weex和NativeScript Vue这样的渲染到本机项目更容易与上游更改保持同步。它还可以轻松地为各种其他目的创建自定义渲染器

## 编译器改进*

> 概要：tree-shaking友好输出，更多AOT优化，具有更好错误信息和源map支持的parser

* 在target是具有tree-shaking功能的bundler时，使用可选功能的模板将使用ES模块导入这些功能。未使用的可选功能将从最终捆绑中删除。
* 由于新的Virtual DOM实现的改进，我们还能够执行更有效的编译时优化，例如静态树提升，静态props提升，运行时的编译器提示以跳过children normalization，VNode创建快速路径等等...
* 我们计划重写解析器，这可以在模板编译错误中提供位置信息，也可以提供模板源map支持。新的解析器可以作为第三方工具集成的基础，例如eslint-plugin-vue和IDE语言服务。

## IE11支持*

> 概要：它将受到支持，但会在一个分开的包中，它有着和Vue 2.x相同的响应限制。

新代码库目前仅针对常青浏览器，并假设他们都支持ES2015。但是，我们知道很多用户在可预见的未来仍然需要支持IE11。对于IE11，大多数使用的ES2015功能都可以进行转换/填充，但Proxy除外。我们的计划是使用相同的API实现另一个观察者，但使用旧的ES5 Object.defineProperty API。将使用此观察器实现单独的Vue 3.x版本。此构建将受到Vue 2.x的相同更改检测警告的影响，因此与3.x的“现代”构建不完全兼容。我们知道这给库的作者带来了一些不便，因为他们需要了解两个不同版本的兼容性，但是当我们将要这么做时，我们确保为此提供明确的指导。

## 如何达成

首先，虽然我们今天宣布，但我们还没有明确的时间表。我们目前所知道的是我们将采取的步骤：

#### 1.runtime原型的内部反馈

这是我们现在所处的阶段。目前，我们已经有一个工作的runtime原型，包括新的观察者，Virtual DOM和组件实现。我们邀请了一组有影响力的社区项目的作者为内部变化提供反馈，并希望在继续前进之前确保他们对变化感到满意。我们希望确保生态系统中的重要库在我们发布3.0的同时准备就绪，以便依赖这些项目的用户可以轻松升级。

#### 2.通过RFC的公众反馈

对于每次重大变更，一旦我们对新设计有了一定程度的信心，我们将打开一个专门的RFC问题，其中包括：

* 变更范围;
* 变革背后的推理：我们获得了什么，以及正在进行哪些权衡;
* 升级路径：是否可以通过可插拔的兼容层或重构以完全向后兼容的方式引入？

我们期待来自社区的更广泛的公众反馈，以帮助我们巩固这些想法。

#### 3.在2.x和2.x-next中引入兼容功能

我们不会忘记2.x！事实上，我们计划使用2.x逐步使用户适应新的变化。我们将通过opt-in适配器逐步将确认的API更改引入2.x。2.x-next将允许用户尝试新的基于Proxy的观察器。
2.x中的最后一个次要版本将成为LTS，并在3.0发布后继续接受18个月的错误和安全修复。

#### 4.alpha阶段

接下来，我们将完成3.0的编译器和服务器端渲染部分并开始制作alpha版本。这些主要用于小型应用中的稳定性测试。

#### 5. Beta阶段

在Beta阶段，我们的主要目标是更新支持库和工具，如Vue Router，Vuex，Vue CLI，Vue DevTools，并确保它们与新核心一起顺利运行。我们还将与社区的主要库作者合作，帮助他们为3.0做好准备。

#### 6. RC阶段

一旦我们认为API和代码库稳定，我们将进入带有API冻结的RC阶段。在此阶段，我们还将开发“compat build”：3.0版本，包含2.x API的兼容性层。此版本还将附带一个开关，您可以打开该开关以在应用程序中为2.x API使用情况，并发出弃用警告。“compat build”可用作将应用程序升级到3.0的指南。

#### 7. IE11构建

最终版本之前的最后一个任务是IE11兼容性构建，如上所述。

#### 8.最终发布

老实说，我们不知道这将在何时发生，但很可能在2019年。我们更关心的是运送稳定的东西而不是特定的日期。有很多工作要做，但我们仍未将到来的欢呼！